# 第一部分 基础知识

## 1.机器语言到汇编语言

### 1.1 机器语言与机器指令

机器语言是机器指令的集合

机器指令是一台机器可以正确执行的命令。

机器指令由一串二进制数表示，例如01010000

### 1.2 汇编语言与汇编指令

汇编语言的主体是汇编指令

汇编指令和机器指令的差别在于指令的表示方法上

汇编指令是机器指令便于记忆的书写格式

汇编指令是机器指令的助记符

例如：

```assembly
机器指令：1000100111011000
操作：将寄存器BX的内容送到AX中
汇编指令：MOV AX,BX
```

寄存器：CPU中可以存储数据的器件

### 1.3 汇编语言的组成

1.汇编指令：机器码的助记符，有对应的机器码。

2.伪指令：没有对应的机器码，由编译器执行，计算机并不执行

3.其他符号：如+，-，*，/等，由编译器识别，没有对应的机器码。

汇编语言的核心是汇编指令，它决定了汇编语言的特性。

## 2.计算机的组成

主板上有：

1.cpu

2.总线

3.内存条

4.扩展槽(接外部设备)

cpu是计算机的核心部件，他控制整个计算机的运行并进行运算。要想让一个cpu工作，就必须向他提供指令和数据。

指令和数据在存储器中存放。

离开了内存，性能再好的cpu也无法工作。

磁盘不同于内存，磁盘上的数据或程序如果读不到内存中，就无法被CPU使用。

### 2.1 指令和数据的表示

计算机中的数据和指令，储存在内存或磁盘上。

在内存或磁盘上，指令和数据没有任何区别，都是二进制信息。

### 2.2 计算机的存储单元

存储器被划分为若干个存储单元，每个储存单元从0开始编号。

一个存储单元可以存储8个bit，即8位二进制数，也就相当于1字节。

### 2.3 计算机的总线

在计算机中专门有连接cpu和其他芯片的导线，通常称为总线。

**地址总线**

地址总线是用于指定内存或I/O设备的地址的电信号线。它传输的是**二进制数据**，即由0和1组成的地址。

"1" 和 "0" 在地址总线中表示的是电信号的两种状态，通常分别对应高电平和低电平。

一个CPU有N根地址线，则可以说这个CPU的地址总线的宽度为N，对应寻址空间2的N次方。

CPU是通过地址总线来指定存储单元的。

地址总线宽度,决定了可寻址的存储单元大小。

**数据总线**

CPU与内存或其它器件之间的数据传送是通过数据总线来进行的。

数据总线的宽度决定了CPU和外界的数据传送速度。

**控制总线**

 CPU通过控制总线对外部器件进行控制

控制总线是一些不同控制线的集合

有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制。

控制总线宽度决定了CPU对外部器件的控制能力。

## 3.内存的读写与地址空间

cpu要想进行数据的读写，必须和外部器件进行三类信息的交互：

1.存储单元的地址(地址信息)

2.器件的选择，读或命令(控制信息)

3.读或写的数据(数据信息)

### 3.1 内存地址空间

CPU地址总线宽度为N，寻址空间为2的N次方B

从CPU角度看地址空间分配：

1.RAM

主板上的RAM
扩展槽上的RAM(例显卡)

2.ROM

系统BIOS
接口卡上的BIOS

所有的物理存储器被看作一个由若干储存单元组成的逻辑储存器

每个物理储存器在这个逻辑储存器中占有一个地址段，即一段地址空间

## 对这一部分知识的总结

---

### 1. 地址总线的基本单位
- 地址总线的基本单位是**字节（Byte）**。
- 每一根地址总线可以唯一地表示一个字节的地址。

### 2. 地址总线的位数与寻址能力

- 地址总线的位数决定了系统能够寻址的最大内存空间大小。
- 计算公式：`2^{地址总线的位数} = 最大可寻址字节数`
- 例如，10根地址总线可以寻址 `2^10 = 1024` 字节，即1KB的内存。

### 3. 地址总线与存储单元的关系
- 每一根地址总线可以唯一地指向一个字节的存储单元。
- 要寻址1KB（1024字节）内存，需要10根地址总线，因为 `2^10  = 1024`。

### 4. 数据总线与数据传输
- 数据总线的位数决定了每次传输的数据量（即一次可以传送的字节数）。
- 例如：
  - 8位数据总线每次传输1字节。
  - 16位数据总线每次传输2字节。
  - 32位数据总线每次传输4字节。

### 5. 地址总线、数据总线、存储器之间的关系
- **地址总线**：负责定位存储单元，即确定要访问的字节位置。
- **数据总线**：负责传输数据，每次传输的大小取决于数据总线的宽度。
- **存储单元**：内存中的最小存储单位，通常为1字节，每个存储单元由唯一的地址总线位组合进行寻址。

---

### 6. 总结

- 地址总线按字节寻址，通过位数决定寻址范围。
- 数据总线决定每次传输数据的大小。

# 第二部分 寄存器

## 4.访问寄存器和内存

### 4.1 CPU的组成

运算器进行信息处理。

寄存器进行信息储存。

控制器协调各种器件进行工作。

外部总线实现CPU和主板上其他器件的联系

内部总线实现CPU内各个器件之间的联系。

### 4.2 寄存器是CPU内部的信息存储单元

寄存器是CPU中程序员可以用指令读写的部件，程序员通过改变各种寄存器中的内容来实现对CPU的控制。

8086cpu有14个寄存器：

通用寄存器：AX,BX,CX,DX

变址寄存器：SI,DI

指针寄存器：SP,BP

指令指针寄存器：IP

段寄存器：CS,SS,DS,ES

标志寄存器：PSW

在8086CPU中，通用寄存器可以把它们分为两个独立的8位寄存器来用。

共性：8086cpu所有的寄存器都是16位的，可以存放两个字节。

一个16位寄存器存储一个16位的数据。

最大值为2的16次方-1

### 4.3 字在寄存器中的存储

字节：记为byte，一个字节由8个bit组成，可以存在八位寄存器中

字：记为word，一个字由两个字节组成，这两个字节分别称为这个字的高位字节和低位字节

8086是16位CPU

8086的字节为16bit

一个字可以存在一个16位寄存器中

这个字的高位字节存在这个寄存器的高8位寄存器

这个字的低位字节存在这个寄存器的低8位寄存器

**总结**

- **“16位”**系统意味着处理器一次可以处理 **16位（2个字节）** 的数据。
- 在**内存**方面，16位处理器能够一次性访问2个字节的数据。
- **16位系统**的结构与寄存器、地址总线、数据总线的宽度密切相关，主要影响的是数据处理能力、寻址能力和内存的读写方式。
- 当我们说“16位”时，通常并不是单指内存里可以存放2个字节，而是指**处理器的数据宽度**，也就是说它一次可以处理或传输的数据位数是16位（2个字节）。

## 5.mov和add指令

我们在使用mov指令时，要保证数据与寄存器之间位数的一致性。

8位寄存器中的数据可以移动到8位寄存器中

16位寄存器中的数据可以移动到16位寄存器中

8位寄存器和8位寄存器做加法，16位寄存器和16位寄存器做加法

1.汇编指令

mov ax, 18

mov ah, 78

add ax, 8

mov ax, bx

add ax, bx

2.控制CPU完成的操作
将18送入AX
将78送入AH
将寄存器AX中的数值加上8
将寄存器BX中的数据送入寄存器AX
将AX,BX 中的内容相加,结果存在AX中

3.用高级语言的语法描述

AX = 18

AH = 78

AX = AX + 8

AX = BX

AX = AX + BX

注：汇编指令不区分大小写

### 16进制数与16位寄存器的关系

#### 1. **基本概念**

- **1字节（Byte）** = **8位（bits）**，也就是说，一个字节中可以存储**8个二进制位**。
- **16进制数**是基于**16**的计数系统，包含符号：`0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F`，共 **16** 个不同的符号。每个符号可以用**4位二进制数**来表示。

#### 2. **16进制到二进制的换算**

- 16进制数的每一位可以用 4位二进制数来表示，因为：
  - 16进制的数值范围是 `0 - 15`。
  - `0` 到 `15` 的值用二进制表示为 `0000` 到 `1111`，正好是 **4位**。

例如：

- `A`（16进制）表示十进制的 `10`，在二进制中是 `1010`（4位）。
- `F`（16进制）表示十进制的 `15`，在二进制中是 `1111`（4位）。

所以，**每1个16进制位**可以用 **4个二进制位**来表示。

#### 3. **16进制与字节的关系**

- **1字节**包含 **8位二进制数**。

- 每1个16进制位等于 4位二进制数，因此：

  - **2个16进制位** = **8位二进制数** = **1字节**。

换句话说，如果你有**两个16进制位**，它们就能够表示**1字节**的数据。例如：

- `FF`（16进制）在二进制中是 `1111 1111`，正好是 **8位**，也就是 **1字节**。

#### 4. **计算16进制数占用的字节数**

要确定**16进制数需要多少字节**来存储，我们可以按照以下步骤进行换算：

- 先计算16进制数的**位数**。
- 每 **2个16进制位**等于 **1字节**，所以可以用16进制位数除以 **2** 来计算需要的字节数。

**举例换算：**

- **16进制数 `8226H`**：
  - 共有 **4个16进制位**。
  - 每 **2个16进制位**等于 **1字节**。
  - 因此，`8226H` 需要 $4 \div 2 = 2$ **字节**来存储。
- **16进制数 `FFFFH`**：
  - 共有 **4个16进制位**。
  - 每 **2个16进制位**等于 **1字节**。
  - 因此，`FFFFH` 需要 **2字节**来存储。
- **16进制数 `A3F1C7H`**：
  - 共有 **6个16进制位**。
  - 每 **2个16进制位**等于 **1字节**。
  - 因此，`A3F1C7H` 需要 $6 \div 2 = 3$ **字节**来存储。

**总结**

- **1个16进制位**等于 **4位二进制数**。
- **2个16进制位**等于 **8位二进制数**，即 **1字节**。
- 要换算16进制数占用的存储字节数，可以将**16进制位数除以2**。

所以，当有 **4个16进制位**时（如 `8226H`），它需要 **2字节**进行存储，因为每2个16进制位占用1字节。

## 6.确定物理地址的方法

物理地址：cpu访问内存单元时要给出内存单元的地址.

所有的内存单元构成的存储空间是一个一维的线性空间

每一个内存单元在这个空间中都有唯一的地址，这个唯一的地址称为物理地址。

### 6.1 16位结构的CPU

16位结构概述了一个CPU具有下面几方面的结构特性

1.运算器一次最多可以处理16位的数据

2.寄存器的最大宽度为16位

3.寄存器和运算器之间的通路为16位

### 6.2 8086cpu给出物理地址的方法

8086cpu的解决方法

用两个16位地址(段地址，偏移地址)合成一个20位的物理地址。

地址加法器合成物理地址的方法

物理地址=段地址*16+偏移地址

相当于左移一位再加上偏移地址

物理地址=段地址*16+偏移地址的本质含义是：CPU在访问内存时，用一个`基础地址`(`段地址*16`)和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。

## 7.内存的分段表示法

### 7.1 用分段的方式管理内存

8086CPU用"物理地址=段地址*16+偏移地址"的方式给出内存单元的物理地址。

内存并没有分段，段的划分来自CPU。

段地址*16必然是16的倍数，所以一个段的起始地址也一定是16的倍数

偏移地址为16位，16位地址的寻址能力为64k，所以一个段的长度最大为64k。

四个段寄存器：

1.CS- 代码段寄存器

2.DS - 数据段寄存器

3.SS - 栈段寄存器

4.ES - 附加段寄存器

## 8.Debug的使用

Debug是DOS系统中的著名的调试程序,也可以运行在windows系统实模式下。

使用Debug程序，可以查看CPU各种寄存器中的内容，内存的情况，并且在机器指令级跟踪程序的运行！

### 8.1 Debug的作用

用R命令查看、改变CPU寄存器的内容

用D命令查看内存中的内容

用E命令改变内存中的内容

用U命令将内存中的机器指令翻译成汇编指令

用A命令以汇编指令的格式在内存中写入机器指令

用T命令执行机器指令

### 8.2 启动debug

在DOS提示符下输入命令:debug

### 8.3 用R命令查看、改变CPU寄存器的内容

R-查看寄存器内容

R 寄存器名-改变指定寄存器内容

### 8.4 用D命令查看内存中的内容

D-列出预设地址内存处的
128个字节的内容

D 段地址:偏移地址-列出内存中指定地址处的内容

D 段地址:偏移地址 结尾偏移地址-列出内存中指定地址范
围内的内容

### 8.5 用E命令改变内存中的内容

E段地址:偏移地址 数据1数据2…

E段地址:偏移地址
	逐个询问式修改
	空格-接受,继续
	回车-结束

### 8.6 用U命令将内存中的机器指令翻译成汇编指令

有汇编指令
	mov ax, 0123H

​	mov bx, 0003H

​	mov ax, bx

​	add ax, bx

对应的机器码为
	B8 23 01

​	BB 03 00

​	89 D8

​	01 D8

e地址数据-写入
d地址-查看
u地址-查看代码

### 8.7 用A命令以汇编指令的格式在内存中写入机器指令

有汇编指令
	mov ax, 0123H

​	mov bx, 0003H

​	mov ax, bx

​	add ax, bx

对应的机器码为
	B8 23 01

​	BB 03 00

​	89 D8

​	01 D8

e地址数据-写入
d地址-查看
u地址-查看代码

### 8.8 用T命令执行机器指令

t-执行CS:IP处的指令
mov ax, 0123H
mov bx, 0003H
mav ax, bx
add ax, bx

### 8.9 用Q命令退出Debug

q - 退出Debug

## 9.CS,IP与代码段

### 9.1 两个关键的寄存器

CS：代码段寄存器

IP：指令指针寄存器

CS:IP ：CPU将内存中CS:IP指向的内容当作指令执行

### 9.2 8086PC工作过程的简要描述

(1)从CS:IP指向内存单元读取指令,读取的指令进入指令缓冲器;

(2)IP=IP+所读取指令的长度,从而指向下一条指令;

(3)执行指令。转到步骤(1),重复这个过程。

### 9.3 CPU是如何区分指令和数据

在8086CPU中，在任意时刻，CPU将段地址寄存器CS和偏移地址寄存器IP中的地址进行组合，然后CPU从这个组合出来的物理地址开始读取的字节全部当作指令来执行。

指令的执行过程

1.CPU从当前的CS和IP指向的内存单元读取指令，然后将读取的指令进入到指令缓冲器

2.IP = IP+所读指令的字节数(长度)，从而指向下一条指令

3.执行指令缓冲器的内容，回到第一步

### 9.4 CPU如何区分指令和数据

计算机运行程序时，**指令和数据的区别**是通过计算机的硬件设计、存储结构、控制逻辑和软件协作来实现的。这种区分是现代计算机体系结构的核心部分，以下从不同角度详细总结。

------

#### **一、存储结构区分：指令与数据的存储位置**

1. **冯·诺依曼架构**
   - 指令和数据存储在**同一存储器**中，使用同一条总线访问。
   - CPU依靠**程序计数器（PC）来确定当前需要读取的内容是指令**。
   - 当PC指向某个内存地址，CPU取出的内容会送到指令寄存器（Instruction Register, IR），并被解释为指令。
   - 当指令需要操作数据时，通过指令提供的内存地址访问对应数据。
2. **哈佛架构**
   - 指令和数据存储在**独立的存储器**中，分别通过指令存储总线和数据存储总线访问。
   - 因为指令和数据在物理上分离，CPU能直接通过总线结构确定访问内容的类型。

------

#### **二、指令执行过程的区分机制**

现代CPU的工作分为多个阶段，指令和数据在不同阶段被处理：

1. **取指阶段（Fetch）**
   - CPU根据**程序计数器（PC）**的值，从存储器中取出指令。
   - 取出的内容被默认作为指令处理，并加载到指令寄存器。
2. **译码阶段（Decode）**
   - 取出的指令被指令译码器解析，确定指令类型和操作数地址。
   - 如果指令需要访问数据，解析结果会提供数据地址和数据存储区域。
3. **执行阶段（Execute）**
   - 根据译码结果，CPU从内存或寄存器中读取数据，执行运算。
   - 此阶段CPU明确知道操作的内容是**数据**。

------

#### **三、硬件设计层面的支持**

1. **程序计数器（PC）**
   - PC专门指向下一条要执行的指令地址，确保从内存中读取的是指令而非数据。
2. **存储区域划分**
   - 嵌入式系统通常会将指令存储在ROM（只读存储器），数据存储在RAM（随机存储器），通过物理分离实现区分。
3. **控制单元**
   - CPU的控制逻辑根据当前操作阶段（如取指阶段或访存阶段）决定读取内容是指令还是数据。
4. **总线设计**
   - 冯·诺依曼架构使用一条总线，访问时依赖PC和控制信号区分指令和数据。
   - 哈佛架构通过指令总线和数据总线天然分离，直接实现区分。

------

#### **四、软件层面的配合**

1. **编译器和链接器**
   - 编译器在生成可执行文件时，将指令存储在代码段（code segment），数据存储在数据段（data segment）。
   - 链接器负责将这些段映射到内存的特定区域，帮助硬件区分指令和数据。
2. **操作系统的内存管理**
   - 操作系统通过内存分段机制将程序的代码段和数据段分开，保护指令不被误修改。
   - 例如，指令存储在只读区域，运行时禁止写操作。

## 10.jmp指令

### 10.1 修改CS，IP的指令

方法1:Debug中的R)命令可以改变寄存器的值 -- rcs,rip
Debug是调试手段,并非程序方式!

方法2:用指令修改

mov cs 2000H
mov ip 0000H

8086CPU不提供对CS和IP修改的指令!

方法3:转移指令jmp

同时修改CS，IP的内容

jmp 段地址:偏移地址

功能：用指令中给出的段地址修改CS，偏移地址修改IP。

仅修改IP的内容

jmp 某一合法寄存器

功能：用寄存器中的值修改IP。

# 第三部分 寄存器(内存)

call指令将IP保存到内存里面，可以用ret拿回。

指令和数据在内存中是没有任何区别的

寄存器之间是相互独立的

jmp 0FF0:0100H中IP所读指令的字节数为多少？

解答：

**分析步骤：**

1. **`jmp` 指令的格式：**
   - `jmp` 是跳转指令，它可以是近跳转（near jump）或远跳转（far jump）。
   - `jmp 0FF0:0100H` 是远跳转（far jump），因为它指定了段地址（`0FF0H`）和偏移地址（`0100H`）。
2. **远跳转的操作码：**
   - 远跳转需要两个部分：
     - 段地址：16 位，占 **2 字节**。
     - 偏移地址：16 位，占 **2 字节**。
   - 指令本身的操作码占 **1 字节**。
3. **总字节数计算：**
   - 操作码：1 字节。
   - 偏移地址：2 字节。
   - 段地址：2 字节。
   - **总计：1 + 2 + 2 = 5 字节**。

CS:IP读取的都是指令

DS:[偏移地址]读取当作数据

## 11.内存中字的存储

对于8086CPU，16位作为一个字。

低位字节存在低地址单元，高位字节存在高地址单元。

### 11.1 字单元

字单元：有两个地址连续的内存单元组成，存放一个字型数据(16位)。

原理：在一个字单元中，低地址单元存放低位字节，高地址单元存放高位字节。

## 12.用DS和[address]实现字的传送

cpu要读取一个内存单元的时候，必须先给出这个内存单元的地址。

在8086PC中，内存地址由段地址和偏移地址组成(段地址：偏移地址)

### 12.1 DS和[address]配合

用DS寄存器存放要访问的数据的段地址。

偏移地址用[...]形式直接给出

**将段地址送入DS的两种方式：**

(1) mov ds, 1000H   错误

(2) mov bx,1000H

​      mov ds,bx            正确

8086CPU不支持将数据直接送入段寄存器
(硬件设计的问题)

套路:数据→一般的寄存器→段寄存器

### 12.2 字的传送

8086CPU可以一次性传送一个字(16位的数据)

## 13.DS与数据段

### 13.1 对内存单元中的数据的访问

对于8086PC机,可以根据需要将一组内存单元定义为一个段。
物理地址=段地址×16+偏移地址
将一组长度为N(N≤64K)、地址连续、起始地址为16的倍数的内存单元当作专门存储数据的内存空间,从而定义了一个数据段。

**用123B0H~123B9H的空间来存放数据**

段地址:123BH
段地址:1230H

起始偏移地址:0000H
起始偏移地址:00BOH

长度:10字节
长度:10字节

**处理方法：(DS)：([address])**

用DS存放数据段的段地址
用相关指令访问数据段中的具体单元,单元地址由[address]指出

**累加数据段中的前3个单元中的数据**
mov ax, 123BH

mov ds, ax

mov al,0

add al, [0]
add al, [1]
add al, [2]

**累加数据段中的前3个字型数据**

mov ax, 123BH

mov ds, ax

mov ax,0

add ax, [0]
add ax, [2]
add ax, [4]

**用mov指令操作数据**
指令形式
mov 寄存器,数据
mov 寄存器,寄存器
mov 寄存器,内存单元
mov 内存单元,寄存器
mov 段寄存器,寄存器

例示
mov ax, 8

mov ax, bx

mov ax, [0]

mov [0], ax

mov ds, ax

**加法add和减法sub指令**

add指令形式
add寄存器,数据
add寄存器,寄存器
add寄存器,内存单元
add内存单元,寄存器

例示
add ax, 8

add ax, bx

add ax, [0]
add [0], ax

sub指令形式
sub寄存器,数据
sub 寄存器,寄存器
sub 寄存器,内存单元
sub 内存单元,寄存器

例示
sub ax, 8

sub ax, bx

sub ax, [0]

sub [0], ax

(1)字在内存中存储时,要用两个地址连续的内存单元来存放,字的
低位字节存放在低地址单元中,高位字节存放再高地址单元中。

(2)用mov指令要访问内存单元,可以在mov指令中只给出单元的偏
移地址,此时,段地址默认在DS寄存器中。

(3)[address]表示一个偏移地址为address的内存单元。

(4)在内存和寄存器之间传送字型数据时,高地址单元和高8位寄存器、
低地址单元和低8位寄存器相对应。

(5)mov、add、sub是具有两个操作对象的指令,访问内存中的数据段
(对照:jmp是具有一个操作对象的指令,对应内存中的代码段)。

(6)可以根据自己的推测,在Debug中实验指令的新格式。

## 14.栈及栈操作的实现

### 14.1 栈结构

栈是一种只能在一端进行插入或删除操作的数据结构。

栈有两个基本的操作:入栈和出栈。
	入栈:将一个新的元素放到栈顶;
	出栈:从栈顶取出一个元素。

栈顶的元素总是最后入栈,需要出栈时,又最先被从栈
中取出。

栈的操作规则:LIFO(Last In First Out,后进先出)

CPU提供的栈机制
	现今的CPU中都有栈的设计。
	8086CPU提供相关的指令,支持用栈的方式访问内存空间。
	基于8086CPU的编程,可以将一段内存当作栈来使用。

PUSH(入栈)和POP(出栈)指令
push ax:将ax中的数据送入栈中
pop ax:从栈顶取出数据送入ax
以字为单位对栈进行操作

8086CPU中,有两个与栈相关的寄存器:
栈段寄存器SS-存放栈顶的段地址
栈顶指针寄存器SP-存放栈顶的偏移地址

任意时刻，SS:SP指向栈顶元素。

### 14.2 栈操作

push ax

(1) SP=SP-2;
(2)将ax中的内容送入SS:SP指向的内存单元处,SS:SP此时指向新栈顶。

pop ax

(1)将SS:SP指向的内存单元处的数据送入ax中;
(2)SP=SP+2,SS:SP指向当前栈顶下面的单元,以当前栈顶下面的单元为新的栈顶

### 14.3 栈顶超界问题的解决

8086CPU不保证对栈的操作不会超界。

8086CPU 只知道栈顶在何处(由SS:SP指示),不知道程序安排的栈空间有多大。

我们在编程的时候要自己操心栈顶超界的问题,要根据可能用到的最大栈空间,来安排栈的大小,防止入栈的数据太多而导致的超界;防止出栈时栈空了仍然继续出栈而导致的超界。

### 14.4 栈作用

临时性保存数据

### 14.5 栈的小结

push、pop实质上就是一种内存传送指令,可以在寄存器和内存之间传送数据,与mov指令不同的是,push和pop指令访问的内存单元的地址不是在指令中给出的,而是由SS:SP指出的。

执行push和pop指令时，SP中的内容自动改变。

**8086CPU提供的栈操作机制:**
在SS,SP中存放栈顶的段地址和偏移地址,入栈和出栈指令根据SS:SP指示的地址,按照栈的方式访问内存单元。

**push指令的执行步骤:**

1)SP=SP-2;

2)向SS:SP指向的字单元中送入数据。

**pop指令的执行步骤:**

1)从SS:SP指向的字单元中读取数据;
2)SP=SP-2。

## 15.段总结

基础

物理地址=段地址×16+偏移地址

做法
	编程时,可以根据需要将一组内存单元定义为一个段。
	可以将起始地址为16的倍数,长度为N (N≤64k)的一组地址连续的内存单元,	定义为一个段。
	将一段内存定义为一个段,用一个段地址指示段,用偏移地址访问段内的单元 	-- 在程序中可以完全由程序员安排。

三种段
	数据段
		将段地址放在DS中
		用mov、add、sub等访问内存单元的指令时,CPU将我们定义的数据段中		的内容当作数据段来访问;
	代码段
		将段地址放在CS中,将段中第一条指令的偏移地址放在IP中
		CPU将执行我们定义的代码段中的指令;
	栈段
		将段地址放在SS中,将栈顶单元的偏移地置放在SP中
		CPU在需要进行栈操作(push、pop)时,就将我们定义的栈段当作栈空间来用。

也就是说，不管我们如何安排，cpu将内存中某段内容当成指令，是因为CS:IP指向那里

CPU将某段内存当作栈空间是因为SS:SP指向那里。

**安全空间**：

0:200 ~ 0:2FFH

或者使用操作系统分配的内存空间

1.系统加载程序时为程序分配的内存空间

2.程序在执行的过程中向系统再去申请内存

# 第四部分 第一个程序

## 16.用汇编语言写的源程序

### 16.1用汇编语言编写程序的工作过程

程序员 -> 汇编程序 -> 编译器 -> 机器码 -> 计算机

伪指令：没有对应的机器码的指令,最终不被CPU所执行。

汇编指令：对应有机器码的指令,可以被编译为机器指令,最终被CPU执行。

汇编程序：包含汇编指令和伪指令的文本。

exe文件除了我们整个程序还包括了一些信息：文件有多大，程序在哪里

### 16.2 三种伪指令

段定义
一个汇编程序是由多个段组成的,这些段被用来存放代码、数据
或当作栈空间来使用。
一个有意义的汇编程序中至少要有一个段,这个段用来存放代码。
定义程序中的段:每个段都需要有段名

段名 segment 一一段的开始

段名 ends        ——段的结束

end(不是ends)

汇编程序的结束标记。若程序结尾处不加end,编译器在编译程序
时,无法知道程序在何处结束。

assume(假设)

含义是假设某一段寄存器和程序中的某一个用segment ... ends定
义的段相关联 -- assume cs:codesg指CS寄存器与codesg关联,将
定义的codesg当作程序的代码段使用。

### 16.3 源程序经编译连接后变为机器码

源程序文件.asm ---编译 连接--- 可执行文件.exe

### 16.4 汇编程序的结构

**1.在Debug中直接写入指令编写的汇编程序**

适用于功能简单、短小精悍的程序
只需要包含汇编指令即可

**2.单独编写成源文件后再编译为可执行文件的程序**
适用于编写大程序
需要包括汇编指令,还要有指导编译器工作的伪指令
源程序由一些段构成,这些段存放代码、数据,或将某个段当作栈空间。

**3.注释**

；---注释

## 17.由源程序到程序运行

### 17.1 由源程序到可执行文件的过程

文本编辑 ---> 源程序文件.asm ---> 编译 ---> 目标文件.obj ---> 连接 ---> 可执行文件.exe ---> 运行程序

目标文件( *. OBJ)是我们对一个源程序进行编译要得到的最终结果。

列表文件( *. LST)是编译器将源程序编译为目标文件的过程中产生的中间结果。

交叉引用文件( *. CRF)同列表文件一样,是编译器将源程序编译为目标文件过程中产生的中间结果。

可执行文件(*.exe)包含两部分内容。1.程序(从源程序中的汇编指令翻译过来的机器码)和数据(源程序中定义的数据) 2.相关的描述信息(比如，程序有多大，要占用多少内存空间)

对源程序的编译结束,编译器输出的最后两行告诉我们这个源程序没有警告错误和必须要改正的错误。

一个汇编程序是由多个段组成的，这些段被用来存放代码，数据或当作栈空间来使用。

一个有意义的汇编程序中至少要有一个段，这个段用来存放代码。

用汇编语言写的源程序，包括伪指令和汇编指令。

### 17.2 windows:

#### 1. 编写源代码

使用汇编语言编写源代码并保存为 `.asm` 文件。你可以使用像 EditPlus、Notepad++、Visual Studio Code 等文本编辑器。

#### 2. 汇编源代码 (Assembling)

使用汇编器（Assembler）将 `.asm` 文件转换为目标文件（`.obj` 文件）。常用的汇编器包括 MASM（Microsoft Macro Assembler）、TASM（Turbo Assembler）等。

以 MASM 为例：

- 命令行输入：

```assembly
ml /c filename.asm
```

#### 3. 链接目标文件 (Linking)

使用链接器（Linker）将 `.obj` 文件转换为可执行文件（`.exe` 文件）。这个过程将把生成的目标代码与库函数（如果有的话）链接起来，生成一个完整的可执行文件。

- 使用 MASM 内置的链接器（Linker）：

```assembly
link filename.obj
```

这个命令会生成 `filename.exe` 文件。

#### 4. 运行可执行文件

在命令行输入可执行文件的名称：

```assembly
filename.exe
```

这将运行编译后的汇编程序。

### 17.3 DOSBox:

#### 1. 编写源代码

使用汇编语言编写源代码并保存为 `.asm` 文件。你可以使用像 EditPlus、Notepad++、Visual Studio Code 等文本编辑器。

#### 2. 汇编源代码 (Assembling)

使用汇编器（Assembler）将 `.asm` 文件转换为目标文件（`.obj` 文件）。常用的汇编器包括 MASM（Microsoft Macro Assembler）、TASM（Turbo Assembler）等。

以 MASM 为例：

- 命令行输入：

```ass
masm filename.asm
```

#### 3. 链接目标文件 (Linking)

使用链接器（Linker）将 `.obj` 文件转换为可执行文件（`.exe` 文件）。这个过程将把生成的目标代码与库函数（如果有的话）链接起来，生成一个完整的可执行文件。

- 使用 MASM 内置的链接器（Linker）：

```ass
link filename
```

#### 4. 运行可执行文件

在命令行输入可执行文件的名称：

```ass
filename
```

#### 5.例子

```assembly
assume cs:codesg
codesg segment
	     
	     mov ax,0123H
	     mov bx,0456H
	     add ax,bx
	     add ax,ax
	   
	     mov ax,4c00H
	     int 21H
codesg ends
end
```

##### 1.**段寄存器与代码段**

- 段寄存器 (`CS`, `DS`, `SS`, `ES`)：用于指定内存中的不同段，如代码段、数据段、堆栈段等。

  - **`CS`（Code Segment）**：代码段寄存器，用于指向程序的代码段。
- 使用 `assume` 语句将 `CS` 段寄存器和代码段标签相关联，表明当前代码段的名字。

##### 2. **汇编器伪指令**

- **`assume`**：告诉汇编器段寄存器（如 `CS`）与哪个段标签相关联。

- `segment` 和 `ends`：
- **`segment`**：用于定义代码或数据的逻辑段的起始位置。
  - **`ends`**：用于标记段的结束。

- **`end`**：标记程序的结束，汇编器编译到此位置后停止。

##### 3. **寄存器操作**

- 寄存器 (`AX`, `BX`, `CX`, 等等)：

  - **`AX`（Accumulator Register）**：常用作算术运算的主要寄存器。
  - **`BX`（Base Register）**：用于基址寻址或存储数据。
  
- 数据传送指令 (`MOV`)：

  - **`MOV` 指令**用于在寄存器、内存和立即数之间传送数据。
- 示例：`mov ax, 0123H`，将十六进制数 `0123H` 赋给 `AX` 寄存器。

##### 4. **算术运算**

- 加法指令 (`ADD`)：

  - **`ADD` 指令**用于将两个数相加，结果存储在指定的目标寄存器中。
  - 示例：`add ax, bx`，将 `BX` 的值与 `AX` 的值相加，结果存储在 `AX` 中。
  - **加倍操作**：`add ax, ax` 将 `AX` 的值加上自身，相当于将 `AX` 乘以 2。

##### 5. **程序退出**

- 系统调用（DOS 中断）：

  - 使用 **中断指令 (`INT`)** 来调用操作系统的服务例程。

  - **`INT 21H`**：调用 DOS 服务。

  - `MOV AX, 4C00H`：
  - **`4C`** 是一个 DOS 系统调用号，用于表示程序正常结束。
    - **`00`** 是返回代码，表示程序以状态代码 `0` 正常结束。

  - 通过 **`INT 21H`** 来执行 `4C` 功能号，从而正常退出程序。

##### 6. **汇编语言程序结构**

- 汇编程序由**段**组成，可以是代码段、数据段、堆栈段等。每个段需要通过 `segment` 和 `ends` 定义。
- 通过段寄存器（如 `CS`、`DS`）来访问相应段的内存内容。
- 程序中通过**寄存器操作**和**内存操作**进行数据处理。
- 结束程序时，通过**系统调用（中断）**将控制权返回给操作系统。

##### 7. **小结**

- **段与寄存器**：使用段寄存器（如 `CS`）来指向代码段，使用 `assume` 语句声明段与寄存器的关系。
- **数据传送与运算**：使用 `MOV` 指令进行数据传送，使用 `ADD` 指令进行算术运算。
- **系统调用结束程序**：使用 `INT 21H` 和功能号 `4C` 来实现程序的正常退出。

## 18.运行及跟踪

### 18.1 用Debug装载程序

语法：

```ass
debug filename.exe
```

程序加载后,DS中存放着程序所在内存区的段地址,这个内存区的偏移地址为0,则程序所在的内存区的地址为:DS:0。
这个内存区的前256个字节存PSP,DOS用来和程序进行通信。
从256字节处向后的空间存放的是程序,CS的值为DS+10H。
程序加载后,CX中存放代码的长度(字节)。

### 18.2 程序执行的不同方式

程序执行的“常态”
DOS启动后,计算机由“命令解释器”(程序command.com)控制
运行可执行程序时,command将程序加载入内存,设置CPU的CS:IP指向程序的第一条指令(即程序的入口),使程序得以运行。
程序运行结束后,返回到“命令解释器”,CPU继续运行command。

程序执行处于开发周期的运行方式

运行Debug时,command程序加载Debug.exe，debug 将程序加载入内存,程序运行结束后要返回到Debug中,使用Q命令退出Debug,将返回到command中。

# 第五部分 [BX]和loop指令

汇编指令：inc指的是increase，将寄存器中的值加上1.这个指令只用了一个字节，可以用来节约内存。

`ES`寄存器用于指定额外的数据段，通常在需要额外内存区域时使用，尤其是在处理大型数据或字符串时，它为数据存储提供了更多的灵活性。

## 19.[...]和(...)

[ ... ] -- (汇编语法规定)表示一个内存单元

( ... ) -- (为学习方便做出的约定)表示一个内存单元或寄存器中的内容

( ... ) -- 所表示的数据有两种：1.字节；2.字

idata -- 表示常量

mov ax,[bx] --- (ax) = (ds * 16 + (bx))

mov [bx],ax --- (ds*16 + (bx)) = (ax)

## 20.Loop指令

**功能：**实现循环(计数型循环)

**指令的格式：**loop 标号

**CPU执行loop指令时要进行的操作**

​	1.(cx)=(cx)-1;
​	2.判断cx中的值
​		不为零则转至标号处执行程序，如果为零则向下执行。

**要求**

cx中要提前存放循环次数,因为(cx)影响着loop指令的执行结果
要定义一个标号

在汇编语言中，标号代表一个地址.

**用cx和loop指令相配合实现循环功能的三个要点:**
(1)在cx中存放循环次数;
(2)用标号指定循环开始的位置;
(3)在标号和loop指令的中间,写上要循环执行的程序段(循环体)。

## 21.Loop指令使用再例

**问题:计算ffff:0006字节单元中的数乘以3,结果存储在dx中**

**程序：**

```assembly
assume cs:code
code segment
		mov ax, 0ffffh
		mov ds, ax
		mov bx, 6
		mov al, [bx]
		mov ah, 0

		mov dx, 0
		mov cx, 3
	s:  add dx, ax
		loop s

		mov ax,4c00h
		int 21h
code ends
end
```

注意：

在汇编源程序中,数据不能以字母开头,要在ffff前面加0

**对于loop 0012的理解**

在 `LOOP 0012` 中，`0012` 作为一个偏移地址，表示汇编程序中某个具体的位置。

典型情况下，这个位置是之前定义的代码部分，通常是用于实现某种需要重复执行的操作，例如**数组遍历、字符串处理**等。

## 22.段前缀的使用

**一个异常现象及对策**

Debug中,mov al,[0]的功能是-- 将DS:0存储单元的值传给AL

**具体异常现象**

在[idata]中，Debug将它解释为[idata]是一个内存单元，idata是内存单元的偏移地址；而编译器将[idata]解释为idata。

**编译(masm)并连接(link)后…**

编译好的程序中,mov al,[0]变成了将常量0传给AL

对策:

1.可以将偏移地址送入到其他寄存器里面，用[寄存器]的方式来访问内存单元。

```assembly
mov ax,2000h
mov ds,ax
mov bx,0
mov al,[bx]
```

但是这样做比较麻烦，所以我们用下面的方式进行解决。

2.在[idata]前显式地写上段寄存器

```assembly
mov ax, 2000h
mov ds,ax

mov bx,0
mov al,ds:[bx]
```

小结(在程序中):
```assembly
mov al,[0] : (al)=0, 同mov al,0
mov al,ds:[0] :(al)=((ds)*16+0)
mov al,[bx] :(al)=((ds)*16+(bx))
mov al,ds:[bx]:与mov al,[bx]相同
```

这些出现在访问内存单元的指令中,用于显式地指明内存单元的段地址的“ds:”、“cs:”、“ss:”或“es:”,在汇编语言中称为段前缀。

**访问连续内存单元--loop和[bx]联手**

问题:计算ffff:0~ffff:b字节单元中的数据的和),结果存储在dx中

```assembly
assume cs: code
code segment
	mov ax,0ffffh
	mov	ds,ax

	mov bx, 0
	mov dx, 0
	mov cx,12

 S: mov al,[bx]
	mov ah,0
	add dx,ax
	inc bx
	loop s

	mov ax,4c00h
	int 21h
code ends
end
```

**段前缀的使用**

在 **DOSBox** 中，汇编语言的 **段前缀**（Segment Override Prefix） 是一种用于显式指定段寄存器的机制，它可以控制处理器从指定的段中读取或写入数据。段前缀在某些情况下非常有用，特别是在你需要手动选择哪个段寄存器（`CS`、`DS`、`ES`、`SS` 等）用于访问内存地址时。

在 x86 体系结构中，默认情况下，处理器根据指令的类型自动选择适当的段寄存器。例如：

- 数据存取通常使用 **`DS`**（数据段）。
- 栈操作使用 **`SS`**（栈段）。
- 代码执行使用 **`CS`**（代码段）。

如果你想强制指令使用不同的段寄存器来访问内存，你可以使用 **段前缀**。在汇编代码中，段前缀通常放在指令前面，用于修改内存访问指令的段选择。

# 第六部分 包含多个段的程序

一个段，它最小占用16，32，64，。。。都是16的倍数

## 23.在代码段中使用数据

在程序的段中存放数据,运行时由操作系统分配空间。
段的类别:数据段、代码段、栈段
各种段中均可以有数据
可以在单个的段中安置,也可以将数据、代码、栈放入不同的段中。

程序中对段名的引用，将被编译器处理为一个表示段地址的数值。

```asse
mov ax, data 

mov ds, ax 

mov bx, ds:[6]
```

在代码段中使用数据

dw的含义是定义字型数据。dw即“define word"

```assembly
;计算 8 个数据的和存到 ax 寄存器
assume cs:code 

code segment 

	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h ;define word 定义8个字形数据

	start:	mov bx, 0  ;标号start
			mov ax, 0  
			
			mov cx, 8
	s:		add ax, cs:[bx]
			add bx, 2
			loop s 
			
			mov ax, 4c00h 
			int 21h 
code ends
end start    ;end除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方
	     	 ;用end指令指明了程序的入口在标号start处，也就是说，“mov bx，0”是程序的第一条指令。
```

在汇编语言中，`start` 是一个标签，具有以下几个主要用途和功能：

**1. 定义程序入口点**

- **程序开始的位置**: `start` 标签通常用作程序的入口点，指示汇编程序或链接器从何处开始执行代码。在代码的最后一行使用 `end start` 指令时，`start` 标签就是程序的执行起点。

**2. 方便代码跳转**

- **控制流**: 标签可以在程序中使用来控制程序的流向。例如，使用跳转指令（如 `jmp`、`call`、`loop` 等）可以使程序跳转到 `start` 或其他标签。通过这种方式，程序可以实现循环、条件执行等功能。

**3. 提高代码可读性**

- **代码组织**: 标签（如 `start`）可以帮助组织和标识代码，使程序更易于阅读和理解。特别是在大型程序中，使用标签可以清楚地标识代码块的开始和结束，提高可维护性。

在汇编语言中，`dw`（**define word**）指令用于定义一个或多个字（word）类型的数据。字是指 16 位（2 字节）大小的数据类型。`dw` 指令允许程序员在数据段中声明和初始化变量或常量，以便在程序中使用。

**`db` (Define Byte)**

- **作用**: 定义一个或多个字节（8 位）。

**`dd` (Define Double Word)**

- **作用**: 定义一个或多个双字（32 位）。

## 24.在代码段中使用栈

```assembly
assume cs:codesg
codesg segment
	dw 0123h,04561,0789h,0abch,Odefh,Ofedh,Ocbah,Q987h
	dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
start.mov ax,cs

	  mov ss,ax

	  mov sp,30h
	  ;入栈
	  ;出栈
	  mov ax,4c00h
      int 21h
codesg ends

end start
```

程序的思路大致如下:
程序运行时,定义的数据存放在cs:0~cs:F单元中,共8个字单元。
依次将这8个字单元中的数据入,然后再依次出栈到这8个字单元中,从而实现数据的逆序存放。
栈需要的内存空间,在程序中通过定义“空”数据来取得。

**入栈操作：**

```assembly
   mov bx,0
   mov cx,8
s: push cs:[bx]
   add bx,2
   loop s
```

**出栈操作：**

```assembly
	mov bx,0
	mov cx,8
s0: pop cs:[bx]
	add bx,2
	loop s0
```

## 25.将数据，代码，栈放入不同段

```assembly
assume cs:code,ds:data,ss:stack
data segment
 dw 0123H,0456H,0789H,OabcH,OdefH,OfedH,OcbaH,0987H
data ends
stack segment
 dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
stack ends
code segment
start:
	 ;初始化各段寄存器
	 ;入栈
	 ;出栈
	 mov ax,4c00h
	 int 21h
code ends
end start
```

**初始化各段寄存器：**

```ass
mov ax,stack
mov ss, Ax
mov sp,20h
mov ax,data
mov ds,ax
```

**入栈：**

```assembly
   mov bx,0
   mov cx,8
s: push (bx)
   add bx,2
   loop s
```

**出栈：**

```assembly
	mov bx,0
	mov cx,8,
s0: pop (bx]
	add bx,2
	loop s0
```

# 第七部分 更灵活的定位内存地址的方法

and:与运算，将相对应的位2个为1，运算结果才为1

or:或运算，将相应的位只要有一个是1，那么运算结果就是1.

**以字符格式给出数据**

## 26.处理字符问题

只要编码和解码采用同样的规则，我们就可以将人能理解的信息存入到计算机，再从计算机中取出。

汇编程序中,用'......'的方式指明数据是以字符的形式给出的,编译器将把它们转化为相对应的ASCII码。

```assembly
assume cs:code,
data segment
	   db 'unIX'
	   db 'foRK'
data ends
code segment
start: mov al,'a'
	   mov bl, 'b'
	   mov ax,4c00h
	   int 21h
code ends
end start
```

`db` 是汇编语言中的伪指令，表示 **Define Byte**（定义字节）。它用于在数据段中定义和初始化字节类型的数据。具体来说：

- **`db 'unix'`**：这条指令在数据段中连续存储了字符串 `'unix'` 的 ASCII 码，每个字符占用一个字节。
- **`db 'foRK'`**：同样，这条指令在数据段中存储了字符串 `'foRK'` 的 ASCII 码。

`start` 是一个 **代码标签**，用于标记代码段中的一个位置，通常被用作程序的 **入口点**。在这段代码中：

- **`start:`**：指示汇编程序从这里开始执行。
- 在程序的最后一行，`end start`，告诉编译器程序的入口点在 `start` 位置。

**作用**：

- **指示程序入口**：在链接和加载过程中，操作系统或运行时环境需要知道从哪里开始执行程序。`start` 标签提供了这个信息。
- **提高代码可读性**：使用明确的标签可以让代码更易读和维护。

DS:0,即075A0H是程序开始的地址,隔过100H程序段前缀

```assembly
大写
A
B
C
D

二进制
01000001
01000010
01000011
01000100

小写
a
b
C
d

二进制
01100001
01100010
01100011
01100100
```

小写字母的ASCII码值比大写字母的ASCII码值大20H。

**大小写转换的问题**

问题:对datasg中的字符串
第一个字符串:小写字母转换为大写字母
第二个字符串:大写字母转换为小写字母

**程序:解決大小写转换的问题**

```assembly
assume cs:codesg,ds:datasg
datasg segment
	db 'BaSiC'
	db 'iNfOrMaTiOn'
datasg ends

codesg segment
start:
	mov ax,datasg
	mov ds, ax
	;第一个字符串:小写字母转换为大写字母
	;第二个字符串:大写字母转换为小写字母
	mov ax,4c00h
	int 21h
codesg ends
end start
```

**第一个字符串:小写字母转换为大写字母**

```assembly
   mov bx,0
   mov cx,5
s: mov al, [bx]
   and al,11011111b
   mov [bx],al
   inc bx
   loop s
```

**第二个字符串:大写字母转换为小写字母**

```assembly
	mov bx,5
	mov cx,11
s0: mov al,[bx]
	or al,00100000b
	mov [bx],al
	inc bx
	loop s0
```

## 27.[bx+idata]方式寻址

**[bx+idata]的含义**

[bxxidata]表示一个内存单元,它的偏移地址为(bx)+idata(bx中的数值加上idata)。
**mov ax,[bx+200]/mov ax,[200+bx]的含义**
将一个内存单元的内容送入ax
这个内存单元的长度为2字节(字单元),存放一个字
内存单元的段地址在ds中,偏移地址为200加上bx中的数值
数学化的描述为:(ax)=((ds)*16+200+(bx))

**指令mov ax,[bx+200]的其他写法(常用)**
mov ax, [200+bx]

mov ax,200[bx]

mov ax, [bx].200

#### 用[bx+idata]的方式进行数组的处理

最上面的把小写字符改成大写字符的例子可以改写成为下面这样

```assembly
  mov ax,datasg
  mov ds,ax
  mov bs,0
  mov cx,5
s:mov al,[bx]
  and al,11011111b
  mov [bx],al
  mov al,[5+bx]
  or al,00100000b
  mov [5+bx],al
  inc bx
  loop s
```

这个与C语言中的数组很像，比如说C语言是A[i],而汇编是0[bx]

## 28.SI和DI寄存器

**SI（源变址寄存器）**

- **作用**：**SI**寄存器作为**源变址寄存器**，用于字符串操作和内存传输中。它通常用于指向内存中的源地址，进行数据操作（如复制或比较数据）。
- **常见用途**：
  - 在字符串操作指令如 `MOVSB`、`MOVSW`、`LODSB` 和 `LODSW` 中，**SI**寄存器指向将要读取数据的源内存位置。
  - **SI**寄存器可以与**DS**（数据段寄存器）一起使用，形成**DS:SI**指针，表示内存中的某个地址，适用于16位和32位模式。
- **例子**：在指令 `MOVSB` 中，**SI**寄存器保存源地址，而该地址的内容会被复制到**DI**指向的目标地址。

**DI（目标变址寄存器）**

- **作用**：**DI**寄存器作为**目标变址寄存器**，用于字符串操作和数据传输指令中。它指向目标内存地址，数据会写入该地址。
- **常见用途**：
  - 在字符串操作指令如 `MOVSB`、`MOVSW`、`STOSB` 和 `STOSW` 中，**DI**寄存器表示目标内存地址，数据从**SI**寄存器（源）复制到目标内存地址。
  - **DI**寄存器可以与**ES**（附加段寄存器）一起使用，形成**ES:DI**指针，表示目标内存地址，适用于16位和32位模式。
- **例子**：在 `MOVSB` 指令中，**DI**寄存器保存目标地址，而**SI**寄存器指向源地址，复制内容到**DI**寄存器指向的目标地址。

**8086CPU有14个寄存器:**

通用寄存器:AX、BX、CX、DX

变址寄存器:SI、DI

指针寄存器:SP、BP

指令指针寄存器:IP

段寄存器:CS、SS、DS、ES

标志寄存器:PSW

**SI和DI常执行与地址有关的操作**

SI和DI是8086CPU中和BX功能相近的寄存器

区别:SI和DI不能够分成两个8位寄存器来使用。

下面的三组指令实现了相同的功能:

(1) mov bx,0

​	 mov ax,[bx]

(2) mov si,0

​	 mov ax,[si]

(3) mov di,0

​	 mov ax,[di]

BX:通用寄存器,在计算存储器地址时,常作为基址寄存器用

SI:source index,源变址寄存器

DI:destination index,目标变址寄存器

应用SI和DI

```assembly
assume cs:codesg,ds:datasg
datasg segment
   db 'welcome to masm!'
   db '..............'
datasg ends
codesg segment
  ....
codesg ends
end
```

代码实现：

```assembly
start: mov ax, datasg
	   mov ds,ax
	   mov si,0
	   mov di,16
	   mov cx,8
	s: mov ax, [si]
	   mov [di],ax
	   add si,2
	   add di,2
	   loop s
	   mov ax,4c00h
	   int 21h
```

## 29.[bx+si]和[bx+di]方式寻址

#### **[bx+si]和[bx+di]方式指定地址**

**[bx+si]表示一个内存单元**
偏移地址为(bx)t(si)(即bx中的数值加上si中的数值)。
**指令movax,[bx+si]的含义**
将一个内存单元的内容送入ax
这个内存单元的长度为2字节(字单元),存放一个字
偏移地址为bx中的数值加上si中的数值
段地址在ds中

**指令mov ax,[bx+si]的数学化的描述**
(ax)=((ds)*16+(bx)+(si)）

**mov ax,[bx+si]的其他写法**

```assembly
mov ax,[bx][si]
```

## 30.[bx+si+idata]和[bx+di+idata]

#### **[bx+si+idata]和[bx+di+idata]方式指定地址**

**[bx+si+idata]表示一个内存单元**
偏移地址为(bx)+(si)+idata,即bx中的数值加上si中的数值再加上idata

指令mov ax,[bx+si+idata]的含义
将一个内存单元的内容送入ax
这个内存单元的长度为2字节(字单元),存放一个字
偏移地址为bx中的数值加上si中的数值再加上idata,段地址在ds中

数学化的描述
(ax)=((ds)*16+(bx)+(si)+idata)

只指令mov ax,[bx+si+idata]的其他写法
```assembly
mov ax,[bx+200+si]

mov ax,[200+bx+si]

mov ax,200[bx][si]

mov ax,[bx].200[si]

mov ax,[bx][si].200

mov ax,[bx][si]
```

## 31.不同的寻址方式的灵活应用

| 形式            | 名称             | 特点                         | 意义                                               | 示例                              |
| --------------- | ---------------- | ---------------------------- | -------------------------------------------------- | --------------------------------- |
| `[idata]`       | 直接寻址         | 用一个常量/立即数来表示地址  | 用于直接定位一个内存单元                           | `mov ax, [200]`                   |
| `[bx]`          | 寄存器间接寻址   | 用一个变量来表示内存地址     | 用于间接定位一个内存单元                           | `mov bx, 0`<br>`mov ax, [bx]`     |
| `[bx+idata]`    | 寄存器相对寻址   | 用一个变量和常量表示地址     | 可在一个起始地址的基础上用变量间接定位一个内存单元 | `mov bx, 4`<br>`mov ax, [bx+200]` |
| `[bx+si]`       | 基址变址寻址     | 用两个变量表示地址           |                                                    | `mov ax, [bx+si]`                 |
| `[bx+si+idata]` | 相对基址变址寻址 | 用两个变量和一个常量表示地址 |                                                    | `mov ax, [bx+si+200]`             |

一般来说，我们在需要暂存数据的时候，我们都应该使用栈。

# 第八部分 数据处理的两个基本问题

dd伪指令：define dword(double word)它是32位数据

## 32.用于内存寻址的寄存器

用于寻址的寄存器：BX,SI,DI,BP。

只有上述的这些寄存器可以用在[...]对内存单元寻址

bx,bp区别：

bx默认指ds段

bp默认指ss段 

## 33.有哪里

#### 1. 立即数（idata）

- 对于直接包含在机器指令中的数据，称为**立即数 (idata)**，数据包含在指令中。

- ```assembly
  mov ax, 1
  add bx, 2000h
  or bx, 00010000b
  mov al, 'a'
  ```

#### 2. 寄存器

- 指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名。

- ```assembly
  mov ax, bx
  mov ds, ax
  push bx
  mov ds:[0], bx
  push ds
  mov ss, ax
  mov sp, ax
  ```

#### 3. 内存：段地址 (SA) 和偏移地址 (EA)

- 指令要处理的数据在内存中，由 **SA**确定内存单元。

  - **段地址默认在 `ds` 中**

  - ```assembly
    mov ax, [0]
    mov ax, [di]
    mov ax, [bx-8]
    mov ax, [bx+si]
    mov ax, [bx+si+8]
    ```

  - **段地址默认在 `ss` 中**：

  - ```assembly
    mov ax, [bp]
    mov ax, [bp+8]
    mov ax, [bp+si]
    mov ax, [bp+si+8]
    ```

  - **显性的给出存放段地址的寄存器**：

  - ```assembly
    mov ax, ds:[bp]   ; (ax) = ((ds) * 16) + (bp)
    mov ax, es:[bx]   ; (ax) = ((es) * 16) + (bx)
    mov ax, ss:[bx+si]; (ax) = ((ss) * 16) + (bx + si)
    mov ax, cs:[bx+si+8]; (ax) = ((cs) * 16) + (bx + si + 8)
    ```

### 有多长

#### 1.字（word）操作(16位)

- 对于操作字数据的指令示例：
  ```asm
  mov ax, 1
  mov bx, ds:[0]
  mov ds, ax
  mov ds:[0], ax
  inc ax
  add ax, 1000

#### 2.字节（byte）操作(8位)

- 对于操作字节数据的指令示例：

- ```assembly
  mov al, 1
  mov al, bl
  mov al, ds:[0]
  mov ds:[0], al
  inc al
  add al, 100
  ```

#### 3.用 `word ptr` 或 `byte ptr` 说明

- 对于显性地指定操作数据类型的指令示例：

  - 字操作：

  - ```assembly
    mov word ptr ds:[0], 1
    inc word ptr [bx]
    inc word ptr ds:[0]
    add word ptr [bx], 2
    ```

  - 字节操作：

  - ```assembly
    mov byte ptr ds:[0], 1
    inc byte ptr [bx]
    inc byte ptr ds:[0]
    add byte ptr [bx], 2
    ```

  ### 说明：

  在没有寄存器参与的内存单元访问指令中，用 `word ptr` 或 `byte ptr` 显性地声明所要访问的内存单元的长度是很必要的。否则，CPU 无法得知所要访问的单元是**字单元**还是**字节单元**。

## 34.用div指令实现除法

**div指令**

div是除法指令，使用div做除法的时候

​	被除数：(默认)放到AX或DX和AX中

​	除数：8位或16位，在寄存器或内存单元中

div指令格式

​	div 寄存器

​	div 内存单元

```assembly
被除数    AX                 DX和AX
除数  8位内存或寄存器      16位内存或寄存器
商       AL                   AX
余数     AH                   DX
```

切记：提前在默认的寄存器中设置好被除数，且默认寄存器不作别的用处。

**在内存单元中实施除法**
双字型数据的定义(例示)

```assembly
data segment
	   db 1  ;定义字节型数据01H,在data:0处,占1个字节
	   dw    ;定义字型数据0001H,在data:1处,占2个字节
	   dd 1  ;定义双字型数据00000001H,在data:3处,占2个字(4个字节)
data ends
```

## 35.用dup设置内存空间

**dup功能和用法**

功能:dup和db、dw、dd等数据定义伪指令配合使用,用来进行数据的重复。

**示例**

```assembly
指令                         功能                                      相当于
db 3 dup (0)             定义了3个字节,它们的值都是0                   db 0,0,0
db 3 dup (0,1,2)         定义了9个字节,由0、1、2重复3次构成             db 0,1,2,0,1,2,0,1,2
db 3 dup ('abcʼ,ABCʼ)    定义了18个字节,构成'abcABCabcABCabcABC'      db 'abcABCabcABCabcABC'
```

**dup的使用格式**

```assembly
db 重复的次数 dup (重复的字节型数据)
dw 重复的次数 dup (重复的字型数据)
dd 重复的次数 dup (重复的双字数据)
```

# 第九部分 转移指令的原理

位移的范围：标号后的偏移地址 - jmp指令后第一个字节的地址

## 36.转移综述

一般情况下指令是顺序地逐条执行的，而在实际中，常需要改变程序的执行流程。

**转移指令**

可以控制CPU执行内存中某处代码的指令。

可以修改IP，或同时修改CS和IP的指令。

**转移指令的分类**

按转移行为
段内转移:只修改IP,如jmp ax
段间转移:同时修改CS和IP,如jmp 1000:0

根据指令对IP修改的范围不同
段内短转移:IP修改范围为-128~127
段内近转移:IP修改范围为-32768~32767

按转移指令
无条件转移指令(如:jmp)
条件转移指令(如:jcxz)
循环指令(如:loop)
过程
中断

## 37.操作符offset

**用操作符offset取得标号的偏移地址**

格式：

offset 标号

例:

```assembly
assume cs:codeseg
codeseg segment
start: mov ax,offset start ;相当于 mov ax,0
	s: mov ax,offset s ;相当于mov ax,3
codeseg ends
end start
```

; nop的机器码占一个字节，起"占位"作用。

## 38.jmp指令

jmp跳转过后，机器码的变化与jmp指令的长度有关，增加的位数就是jmp指令的长度

**jmp指令 -- 无条件转移**

jmp指令的功能
无条件转移,可以只修改IP 也可以同时修改CS和IP

jmp指令要给出两种信息:
转移的目的地址
转移的距离(段间转移，段内短转移，段内近转移)

- 段间转移(远转移):  jmp2000:1000
- 段内短转移:jmp short 标号;IP的修改范围为-128~127,8位的位移
- 段内近转移:jmp near ptr 标号;IP的修改范围为-32768~32767,16位的位移

**CPU在执行jmp指令的时候并不需要转移的目的地址。**

**jmp指令：依据位移进行转移**

jmp short的机器指令中，包含的是跳转到指令的相对位置，而不是跳转的目标位置。

**两种段内的转移**

短转移：jmp short 标号

功能：(IP)=(IP)+8位位移

原理：

(1)8位位移='标号'处的地址-jmp指令后的第一个字节的地址;
(2)short指明此处的位移为8位位移;
(3)8位位移的范围为-128~127字节,用补码表示;
(4)8位位移由编译程序在编译时算出。

近转移：jmp near ptr 标号

功能：(IP)=(IP)+16位位移

段内转移：near ptr 指明了相对于当前IP的转移位移，而不是转移的目的地址。

原理：

(1)16位位移=“标号”处的地址-jmp指令后的第一个字节的地址;
(2)near ptr指明此处的位移为16位位移,进行的是段内近转移;
(3)16位位移的范围为-32769~32767字节,用补码表示;
(4)16位位移由编译程序在编译时算出。

远转移：jmp far ptr 标号

段间转移：far ptr指明了跳转到的目的地址,即包含了标号的段地址CS和偏移地址IP。

**转移地址在寄存器中的jmp指令**

指令格式：jmp 16位寄存器

功能：IP = (16位寄存器)

**转移地址在内存中的jmp指令**

```assembly
jmp word ptr 内存单元地址					jmp dword ptr 内存单元地址
		段内转移								段间转移
功能：从内存单元地址处开始存放着一个字，       功能：从内存单元地址处开始存放着两个字,高地址处的字
是转移的目的偏移地址。							  是转移的目的段地址,低地址处是转移的目的偏移地址。
```

eg:

```assembly
段内转移:jmp word ptr 内存单元地址 ;jmp word ptr [bx]
段间转移:jmp dword ptr 内存单元地址 ;jmp dword ptr [bx] 
```

## 39.其他转移指令

**jcxz指令**

指令格式：jcxz 标号

功能：如果(cx)=0，则转移到标号处执行

​	    当(cx)≠0时，什么也不做(程序向下执行)

​	    当(cx)=0时，(IP)=(IP)+8位位移

```assembly
	8位位移=“标号”处的地址-jcxz指令后的第一个字节的地址;
	8位位移的范围为-128~127,用补码表示;
	8位位移由编译程序在编译时算出。
```

jcxz是有条件转移指令
	所有的有条件转移指令都是短转移
	对IP的修改范围都为-128~127
	在对应的机器码中包含转移的位移,而不是目的地址

**loop指令**

指令格式:loop 标号

指令操作
(1) (cx)=(cx)-1;
(2)当(cx)=0时,则转移到标号处执行
	当(cx)=0时,程序向下执行
如果(cx)≠0,(IP)=(IP)+8位位移
	8位位移=“标号”处的地址-loop指令后的第一个字节的地址
	8位位移的范围为-128~127,用补码表示
	8位位移由编译程序在编译时算出

**根据位移进行"相对"转移的意义**

对IP的修改是根据转移目的地址和转移起始地址之间的位移来进行

jmp short 标号
jmp near ptr 标号
jcxz 标号
loop 标号

注意：在它们对应的机器码中不包含转移的目的地址，而包含的是到目的地址的位移。

# 第十部分 CALL和RET指令

## 40.call指令和ret指令

**模块化程序设计**

调用子程序：call指令

返回：ret指令

实质：流程转移指令，它们都修改IP，或同时修改CS和IP

ret指令用栈中的数据，修改IP的内容，从而实现近转移

retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移

**近转移**：

- 只涉及修改偏移量，不需要改变段寄存器。
- 用于同一段内的跳转。
- 地址大小较小（通常是16位偏移）。

**远转移**：

- 涉及修改段寄存器和偏移量。
- 用于跨段的跳转。
- 地址大小较大（通常是16位段地址 + 16位偏移地址）。

**call指令**

字面意思：调用子程序

实质：流程转移

​	call指令实现转移的方法和jmp指令的原理相似

格式：call 标号

CPU执行call指令，进行两步操作：

(1)将当前的IP或CS和IP压入栈中;
(2)转移到标号处执行指令。

注意：call指令不能实现短转移。

call 标号

```assembly
(1)(sp)=(sp)-2
   ((ss)*16+(sp)) =(IP)
(2)(IP)=(IP)+16位位移
```

相当于

```assembly
push IP
jmp near ptr
```

16位位移“标号”处的地址-call指令后的第一个字节的地址;
16位位移的范围为-32768~32767,用补码表示;
16位位移由编译程序在编译时算出。

**指令"call far ptr 标号"实现的是段间转移**

CPU执行"call far ptr 标号"时的操作

(1) 

```assembly
(sp) =(sp) -2
((ss) ×16+(sp)) =(CS)
(sp) = (sp)-2
((ss) x16+(sp)) =(IP)
```

(2)

(CS)=标号所在的段地址

(IP)=标号所在的偏移地址

"call far ptr 标号"相当于

push CS

push IP 

jmp far ptr 标号

call 标号”类似”jmp near ptr标号”,对应的机器指令中为相对于当前IP的转移位移,而不是转移的目的地址,实现段内转移。
指令“call far ptr标号”实现的是段间转移!

**转移地址在寄存器中的call指令**

指令格式
	call 16位寄存器

功能

​	(sp) = (sp)-2

​	((ss)*16+(sp)) =(IP)

​	(IP)(16位寄存器)

相当于进行

​	push (P)

​	jmp 16位寄存器

**转移地址在内存中的call指令**

call word ptr 内存单元地址

相当于：

push IP

jmp word ptr 内存单元地址

call dword ptr 内存单元地址

相当于

push CS

push IP

jmp dword ptr 内存单元地址

**返回指令：ret和retf**

ret指令

功能：用栈中的数据，修改IP内容，从而实现近转移；

相当于：

pop IP

retf指令

功能：用栈中的数据，修改CS和IP的内容，从而实现远转移；

相当于：

pop IP 

pop CS

## 41.call和ret的配合使用

**具有子程序的源程序的框架**

```assembly
assume cs: code
code segment
main:...
	 call sub1 ;调用子程序sub1
	 ...
	 mov ax, 4c00h
	 int 21h
sub1:...       ;子程序sub1开始
	 call sub2 ;调用子程序sub1
	 ...
	 ret       ;子程序返回
sub2:...       ;子程序sub2开始
	 ...
	 ret       ;子程序返回
code ends
end main
```

**例：为call和ret指令设置栈**

```assembly
assume cs:code, ss:stack
stack segment
	   db 8 dup (0)
	   db 8 dup (0)
stack ends
code segment
start: mov ax, stack
	   mov ss,ax
	   mov sp,16
	   mov ax, 1000
	   call s
	   mov ax, 4c00h
	   int 21h
	s: add ax, ax
	   ret
code ends
end start
```

## 42.乘法：mul指令

**格式：**

mul 寄存器

mul 内存单元

```assembly
      8位乘法                               16位乘法
被乘数   AL                                   AX
乘数  8位寄存器或内存字节单元              16位寄存器或内存字单元
结果     AX                             DX(高位)和AX(低位)
例    mul bl                         mul wprd ptr [bx+si+8]
    --(ax)=(al)*(bl)               --(ax)=(ax)*((ds)*16+(bx)+(si)+8)结果的低16位; 
      mul byte ptr ds:[0]            (dx)=(ax)*((ds)*16+(bx)+(si)+8)结果的高16位;
    --(ax)=(al)*((ds)*16+0)
```

## 43.汇编语言的模块化程序设计

调用子程序：call指令

返回：ret指令

子程序：根据提供的参数处理一定的事务,处理后,将结果(返回值)提供给调用者。

**参数和结果传递的问题**

根据提供的N，计算N的三次方

**用寄存器传递参数**

参数放到bx中，即(bx)=N

子程序中用多个mul指令计算N的三次方

将结果放到dx和ax中：(dx:ax)=N的三次方

**用内存单元批量传递数据**

将批量数据放到内存中,然后将它们所在内存空间的首地址放在寄存器中,传递给需要的子程序。
对于具有批量数据的返回结果,也可用同样的方法。

**用栈传递参数**

原理：由调用者将需要传递给子程序的参数压入栈中，子程序从栈中取得参数。

## 44.寄存器的冲突问题

**代码:编程将data段中的字符串转化为大写**

```assembly
assume cs:code
data segment
	 db 'conversation',0
 data ends
code segment
start: mov ax,data
	   mov ds,ax
	   mov si,0
	   call capital
	   mov ax,4c00h
	   int 21h
capital: mov cl, [si]
		 mov ch, 0
		 jcxz ok
		 and byte ptr [si], 11011111b
	  	 inc si
		 jmp short capital
	  ok: ret
code ends
end start
```

注意：cx既用于循环，又用于读取数据--冲突

**寄存器冲突问题的解决**

两个可能的方案

1.在编写调用子程序的程序时,注意看看子程序中有没有用到会产生冲突的寄存器
	如果有,调用者使用别的寄存器;

​	调用子程序的程序会很麻烦,必须要小心检查所调用的子程序中是否有将产生冲	突的寄存器。

​	要调用子程序,必须看到子程序源码 !?

2.在编写子程序的时候，不要使用会产生冲突的寄存器

​	子程序应该是独立的，编写子程序的时候无法知道也不必知道将来的调用	情况。

**希望**

(1)编写调用了程序的程序的时候不必关心子程序到底使用了哪些寄存器;
(2)编写子程序的时候不必关心调用者使用了哪些寄存器;
(3)不会发生寄存器冲突。

**子程序标准框架**

```assembly
子程序开始:子程序中使用的寄存器入栈
		 子程序内容
		 子程序使用的寄存器出栈
		 返回(ret、retf)
```

**寄存器冲突问题的解决示例**

```assembly
assume cs:code
data segment
	 db 'word',0
	 db 'unix',0
	 db 'wind',0
	 db 'good',0
data ends

code segment
 start: mov ax,data
		mov ds,ax
		mov bx,0
		mov cx,4
     s: mov si bx
		call capital
		add bx,5
		loop s
		mov ax,4c00h
		int 21h
		;子程序
capital: push cx
		push si
change: mov cl, sil
		mov ch,0
		jcxz ok
		and byte ptr [si],11011111b
		inc si
		jmp short change
	ok: pop si
		pop cx
		ret
code ends
end start
```

# 第十一部分 标志寄存器

## 45.标志寄存器

标志寄存器：PSW/FLAGS

PSW别称：程序状态字

**标志寄存器的结构**
flag寄存器是按位起作用的,也就是说,它的每一位都有专门的含义,记录特定的信息。
8086CPU中没有使用flag的1、3、5、12、13、14、15位,这些位不具有任何含义。

**标志寄存器的作用**
用来存储相关指令的某些执行结果
用来为CPU执行相关指令提供行为依据
用来控制CPU的相关工作方式

**直接访问寄存器的方法**

pushf:将标志寄存器的值压栈

popf:从栈中弹出数据，送入标志寄存器中

**ZF-零标志**

ZF标记相关指令的计算结果是否为0
ZF=1,表示“结果是0”,1表示“逻辑真”
ZF=0,表示“结果不是0”,0表示“逻辑假”

**PF-奇偶标志**

PF记录指令执行后,结果的所有二进制位中1的个数:
1的个数为偶数,PF=1;
1的个数为奇数,PF=0。

**SF-符号标志**

SF记录指令执行后,将结果视为有符号数
结果为负,SF=1;
结果为非负,SF=0

SF标志是CPU对有符号数运算结果的一种记录。
将数据当作有符号数来运算的时候,通过sF可知结果的正负;将数据当作无符号数来运算,SF的值则没有意义,虽然相关的指令影响了它的值。

**基础：有符号数与补码**

计算机中有符号数一律用补码来表示和存储。
正整数的补码是其二进制表示,与原码相同
例:+9的补码是00001001
负整数的补码,将其对应正数二进制的所有位取反(包括符号位,0变1,1变0)后加1
例 :- 5的补码
-5对应正数5(00000101)→所有位取反(11111010)→加1(11111011)
所以-5的补码是11111011。

**CF-进位标志**

在进行无符号数运算的时候,CF记录了运算结果的最高有效位向更高位的进位值,或从更高位的借位值。

CF记录指令执行后,
有进位或借位,CF=1
无进位或借位,CF=0

对于位数为N的无符号数来说,其对应的二进制信息的最高位即第N-1位,是最高有效位

假想存在的第N位,就是相对最高有效位的更高位。

**OF-溢出标志**

在进行有符号数运算的时候,如结果超过了机器所能表示的范围称为溢出

OF记录有符号数操作指令执行后,
有溢出,OF=1
无溢出,OF=0

机器所能表达的范围
以8位运算为例,结果用8位寄存器或内存单元来存放,机器所能表示的范围就是-128~127。
同理,对于16位有符号数,机器所能表示的范围是-32768~32767
注意,此处溢出只是对有符号数运算而言。

**注：CF和OF的区别**

CF是对无符号数运算有意义的进/借位标志位
OF是对有符号数运算有意义的溢出标志位

## 46.带进(错)位的加减法

**adc-带进位加法指令**

adc是带进位加法指令,它利用了CF位上记录的进位值。
格式:adc 操作对象1,操作对象2
功能:操作对象1=操作对象1+操作对象2+CF
例:adc ax,bx实现的功能是:(ax)=(ax)+(bx)+CF

**sbb-带借位减法指令**

Isbb:带借位减法指令
格式:sbb操作对象1,操作对象2
功能:操作对象1=操作对象1-操作对象2-CF
与sub区别:利用CF位上记录的借位值
比如:sbb ax,bx
实现功能:(ax)=(ax)-(bx)-CF

## 47.cmp与条件转移指令

**cmp指令**

格式:cmp 操作对象1,操作对象2
功能:计算 操作对象1-操作对象2

cmp是比较指令,功能相当于减法指令,只是
不保存结果。

cmp指令执行后,将对标志寄存器产生影响。

应用
其他相关指令通过识别这些被影响的标志寄存器位来得知比较结果。

例如：

```assembly
指令：cmp ax,ax                         mov ax,8
									   mov bx,3
									   cmp ax,bx
功能：故(ax)-(ax)的运算,结果为0,但并不     (ax)=8, (bx)=3
	 在ax中保存,仅影响flag的相关各位。
标志寄存器：ZF=1 PF=1 SF=0 CF=0 OF=0    ZF=1 PF=1 SF=0 CF=0 OF=0
```

应用方法：用标志寄存器值，确定比较结果。

**无符号数比较与标志位取值**

思路：通过cmp指令执行后相关标志位的值，可以看出比较的结果。

指令：cmp ax,bx

```assembly
比较关系   (ax)?(bx)    (ax)-(bx)特点           标志寄存器
等于       (ah)=(bh)    (ah)-(bh)=0             ZF=1
不等于     (ah)!=(bh)   (ah)-(bh)!=0            SF=1且OF=0
小于		 (ax)<(bx)    (ax)-(bx)为负,且不溢出    SF=1且OF=1
大于       (ax)>(bx)    (ax)-(bx)为负,且溢出      SF=1且OF=1
大于等于    (ax)≥(bx)    (ax)-(bx)为非负,且无溢出  SF=0且OF=0
小于等于    (ax)<(bx)    (ax)-(bx)为非负,且有溢出  SF=0或OF=1
```

仅凭结果正负(SF)无法得出结论,需要配合是否溢出(OF)得到结论。推导略。

**条件转移指令**

根据单个标志位转移的指令

| 指令            | 含义                   | 测试条件 |
| --------------- | ---------------------- | -------- |
| **je/jz**       | 相等/结果为0           | ZF=1     |
| **jne/jnz**     | 不等/结果不为0         | ZF=0     |
| **js**          | 结果为负               | SF=1     |
| **jns**         | 结果非负               | SF=0     |
| **jo**          | 结果溢出               | OF=1     |
| **jno**         | 结果未溢出             | OF=0     |
| **jp**          | 奇偶位为1              | PF=1     |
| **jnp**         | 奇偶位不为1            | PF=0     |
| **jb/jnae/jc**  | 低于/不高于等于/有借位 | CF=1     |
| **jnb/jae/jnc** | 不低于/高于等于/无借位 | CF=0     |

```assembly
j-Jump e-Egual n-Not b-Below a-Above L-less g-Greater
s-Sign C-carry p-Parity o-Overflow z-Zero
```

根据无符号数比较结果进行转移的指令

| 指令            | 含义         | 测试条件   |
| --------------- | ------------ | ---------- |
| **jb/jnae/jc**  | 低于则转移   | CF=1       |
| **jnb/jae/jnc** | 低于则转移   | CF=0       |
| **jna/jbe**     | 不高于则转移 | CF=1或ZF=1 |
| **ja/jnbe**     | 高于则转移   | CF=0且ZF=0 |

根据有符号数比较结果进行转移的指令

| 指令        | 含义             | 测试条件     |
| ----------- | ---------------- | ------------ |
| **jl/jnge** | 小于则转移       | SF=1 且 OF=0 |
| **jnl/jge** | 不小于转移       | SF=0 且 OF=0 |
| **jle/jng** | 小于等于则转移   | SF=0 或 OF=1 |
| **jnle/jg** | 不小于等于则转移 | SF=1 且 OF=1 |

**条件转移指令的使用**

jxxx系列指令和cmp指令配合,构造条件转移指令

​	不必再考虑cmp指令对相关标志位的影响和jxxx指令对相关标志位的检测
​	可以直接考虑cmp和jxxx指令配合使用时表现出来的逻辑含义。

## 48.条件转移指令

**条件转移指令 jxxx——je/jma/jae...**

可以根据某种“条件”,决定是否“转移”程序执行流程。

“转移”=修改IP

**如何检测条件?**

通过检测标志位,由标志位体现条件

条件转移指令通常都和cmp相配合使用,cmp指令改变标志位

## 49.DF标志和串传送指令

**DF-方向标志位**

功能：在串处理指令中，控制每次操作后si,di的增减

​			DF=0：每次操作后si，di递增

​			DF=1：每次操作后si，di递减

对DF位进行设置的指令：

​	cld指令：将标志寄存器的DF位设为0(clear)

​	std指令：将标志寄存器的DF位设为1(setup)

**串传送指令1:movsb**
功能:(以字节为单位传送)
(1) ((es)×16+(di)) =((ds) ×16+ (si))
(2)如果DF=0则:(si)=(si)+1
						  (di) = (di) + 1
	如果DF=1则:(si)=(si)-1
					 	 (di) = (di) - 1
**串传送指令2:movsw**
功能:(以字为单位传送)
(1) ((es)×16+(di)) =((ds) ×16+ (si))
(2)如果DF=0则:(si)=(si)+2
						   (di) = (di) + 2
	如果DF=1则:(si)=(si)-2
					  	(di) = (di) - 2

**rep指令**

rep指令常和串传送指令搭配使用

功能：根据cx的值，重复执行后面的指令

用法：

```assembly
rep movsb

s : movsb
	loop s
	
rep movsw

s : movsw
	loop s
```

## 50.位移指令

逻辑左移 SHL OPR, CNT

循环左移 ROL OPR,CNT

逻辑右移 SHR OPR,CNT

循环右移 ROR OPR,CNT

算术左移 SAL OPR,CNT

算术右移 SAR OPR,CNT

带进位循环左移 RCL OPR,CNT

带进位循环右移 RCR OPR,CNT

S,SH-shift  L-left  R-Right  A-Arithmetic  R,RO-Rotate  C-Carry

示例：逻辑移位指令shl和shr

SHL OPR,CNT,将OPR逻辑左移CNT位
(1)将寄存器或内存单元中的数据向左移位
(2)将最后移出的一位写入CF中
(3)最低位用0补充

## 51.操作显存数据

**显示的原理**

屏幕上的内容=显存中的数据

```assembly
行数        各行所需的字节数          显示缓冲区地址范围
 0            160(AOH)             B800:0000~B800:009F
 1            160(AOH)             B800:00A0~B800:013F
 2            160(AOH)             B800:0140~B800:01DF
...
 24           160(AOH)             B800:0F00~B800:0F9F
```

## 52.描述内存单元的标号

 **使用代码的直接定址表解决问题**

直接定址表法

用查表的方式,通过依据数据,直接计算出所要找的元素的位置

直接定址表分类
数据的直接定址表
代码的直接定址表

## 53.中断及其处理

**中断的概念**

中断：CPU不再接着(刚执行完的指令)向下执行，而是转去处理中断信息。

内中断:由CPU内部发生的事件而引起的中断

外中断:由外部设备发生的事件引起的中断

**8086的内中断**

CPU内部产生的中断信息

1.除法错误，比如：执行div指令产生的除法溢出

2.单步执行

3.执行into指令

4.执行int指令

**8086的中断类型码**

1.除法错误：0

2.单步执行：1

3.执行into指令

4.执行int n指令，立即数n为中断类型码

**中断处理程序**

CPU接到中断信息怎么办?
执行中断处理程序

中断处理程序在哪里?
中断信息和其处理程序的入口地址之间有某种联系,CPU根据中断信息可以找到要执行的处理程序。

中断向量表
由中断类型码,查表得到中断处理程序的入口地址,从而定位中断处理程序。

**中断过程**

中断过程由CPU的硬件自动完成;
用中断类型码找到中断向量,并用它设置CS和IP

8086CPU的中断过程

1.从中断信息中取得中断类型码

2.标志寄存器的值入栈--中断过程中要改变标志寄存器的值，需要先行保护

3.设置标志寄存器的第8位TF和第9位IF的值为0

4.CS的内容入栈

5.IP的内容入栈

6.从中断向量表读取中断处理程序的入口地址，设置IP和CS。

## 54.中断处理程序及其结构

**中断过程**

(1)取得中断类型码N;
(2) pushf
(3) TF = 0, IF = 0
(4) push CS
( 5) push IP
(6) `(IP)=(N*4), (CS) =(N*4+2)`

CPU随时都可能检测到中断信息,所以中断处理程序必须常驻内存(一直存储在内存某段空间之中)。

中断处理程序的入口地址,即中断向量,必须存储在对应的中断向量表表项中(0000:0000-0000:03FF)。

## 55.单步中断

Debug利用了CPU提供的单步中断的功能，来让CPU能执行一条指令就停下。

使用t命令时，Debug将TF标志设为1，使CPU工作在单步中断方式。

**单步中断过程与处理**

两个和中断相关的寄存器标志位
TF陷阱标志(Trap flag):用于调试时的单步方式操作。当TF=1时,每条指令执行完后产生陷阱,由系统控制计算机;当TF=0时,CPU正常工作,不产生陷阱。

IF中断标志(Interrupt flag):当IF=1时,允许CPU响应可屏蔽中断请求;当IF=0时,关闭中断。

CPU在执行完一条指令之后,如果检测到标志寄存器的TF位为1,则产生单步中断(中
断类型码为1),引发中断过程,执行中断处理程序。

中断过程:
(1)取得中断类型码1;
(2)标志寄存器入栈,TF、IF设置为0;
(3)CS、IP入栈;
(4)`(IP)=(1*4),(CS)=(1*4+2)。`

**中断处理程序也由一条条指令组成的。**
如果在执行中断处理程序之前,TF=1,则CPU在执行完中断处理程序的第一条指令后,又要产生单步中断,转去执行单步中断的中断处理程序的第一条指令 ……
上面的过程将陷入一个永远不能结束的循环,CPU永远执行单步中断处理程序的第一条指令。
所以,在进入中断处理程序之前,设置TF=0。

**应用：中断不响应的情况**

一般情况下,CPU在执行完当前指令后,如果检测到中断信息,就响应中断,引发中断过程。
在有些情况下,CPU在执行完当前指令后,即便是发生中断,也不会响应。
例:在执行完向ss寄存器传送数据的指令后,即便是发生中断,CPU也不会响应。
原因:ss:sp联合指向栈顶,而对它们的设置应该连续完成。
以此保证对栈的正确操作!

## 56.由int指令引发的中断

**int n引起的中断**

CPU内部产生的中断信息

除法错误

单步执行

执行into指令

执行int指令

int格式：int n,n为中断类型码

功能：引发中断过程。

CPU执行int n指令,相当于引发一个n号中断的中断过程,执行过程如下:
(1)取中断类型码n;
(2)标志寄存器入栈,IF=0,TF=0;
(3)CS、IP入栈;
(4)`(IP)=(n*4),(CS)=(n*4+2).`

**中断处理程序的常规的步骤**
(1)保存用到的寄存器。
(2)处理中断。
(3)恢复用到的寄存器。
(4)用iret指令返回。

## 56.BIOS和DOS中断处理

**BIOS--基本输入输出系统**

BIOS，是在系统板的ROM中存放着一套程序

容量：8kb

地址：从FE000H开始

**BIOS中的主要内容**
(1)硬件系统的检测和初始化程序
(2)外部中断和内部中断的中断例程
(3)用于对硬件设备进行I/O操作的中断例程
(4)其他和硬件系统相关的中断例程 

**DOS中断**

DOS 中断类(INT 21H中断)
1、字符功能调用类(Character-Oriented Function)
2、目录控制功能(Directory-Control Function)
3、磁盘管理功能(Disk-Management Function)
4、文件操作功能(File Operation Function)
5、文件操作功能(FCB)(File Operation Function)
6、记录操作功能(Record Function)
7、记录操作功能(FCB)(Record Function)
8、内存分配功能(Memory-Allocation Function)
9、系统功能(System Function)
10、进程控制功能(Process-Control Function)
11、时间和日期功能(Time and Date Function)

BIOS和DOS在所提供的中断例程中包含了许多子程序,这些子程序实现了程序员在编程的时常用到的功能。

和硬件设备相关的DOS中断例程中,一般都调用BIOS的中断例程。

**BIOS和DOS中断例程的安装过程**

(1)CPU一加电,初始化(CS)=OFFFEH,(IP)=0,自动从FFFF:0单元开始执行程序。FFFF:0处有一条转跳指令,CPU执行该指令后,转去执行BIOS中的硬件系统检测和初始化程序。

(2)初始化程序将建立BIOS所支持的中断向量,即将BIOS提供的中断例程的入口地址登记在中断向量表中。

(3)硬件系统检测和初始化完成后,调用int19h进行操作系统的引导。从此将计算机交由操作系统控制。

(4)DOS启动后,除完成其它工作外,还将它所提供的中断例程装入内存,并建立相应的中断向量。

## 57.端口的读写

**CPU可以直接读写3个地方的数据**

1.CPU内部的寄存器

2.内存单元

3.端口

各种芯片工作时，都有一些寄存器由CPU读写

从CPU角度，将各寄存器当端口，并统一编址

CPU用统一的方法与各种设备通信

**读写内存与寄存器的指令**

mov add,push...

**读写端口的指令**

in:CPU从端口读取数据

out:CPU从端口写入数据

**端口的读写**

访问端口的方法
   例:(in al 60h);从60h号端口读入一个字节
执行时与总线相关的操作

1. CPU通过地址线将地址信息60h发出;
2. CPU通过控制线发出端口读命令,选中端口所在的芯片,并通知要从中读取数据;
3. 端口所在的芯片将60h端口中的数据通过数据总线送入CPU。

在in和out指令中,只能使用ax 或al来存放从端口中读入的数据或要发送到端口中的数据。访问8位端口时用al,访问16位端口时用ax。

## 58.操作CMOS RAM芯片

**CMOS RAM芯片**

(1)包含一个实时钟和一个有128个存储单元的RAM存储器。
(2)128个字节的RAM中存储:内部实时钟、系统配置信息、相关的程序(用于开机时配置系统信息)。
(3)CMOS RAM芯片靠电池供电,关机后其内部的实时钟仍可正常工作,RAM中的信息不丢失。
(4)该芯片内部有两个端口,端口地址为70h和71h,CPU通过这两个端口读写CMOS RAM。
	70h地址端口,存放要访问的CMOS RAM单
	元的地址;
	71h数据端口,存放从选定的单元中读取的
	数据,或要写入到其中的数据。

(5)读取CMOS RAM的两个步骤

将要读取的单元地址送入70h地址端口

从数据端口71h读出指定单元内容

## 59.外设连接与中断

**CPU可以直接读写3个地方的数据**

1.CPU内部的寄存器

2.内存单元

3.端口

外中断：由外部设备发生的事件引起的中断。

**可屏蔽中断**

可屏蔽中断是CPU可以不响应的外中断。
CPU是否响应可屏蔽中断,要看标志寄存器的IF位的设置。
当CPU检测到可屏蔽中断信息时:
	如果IF=1,则CPU在执行完当前指令后响应中断 引发中断过程;
	如果IF=0,则不响应可屏蔽中断。

**不可屏蔽中断**

不可屏蔽中断是CPU必须响应的外中断。

当CPU检测到不可屏蔽中断信息时,则在执行完当前指令后,立即响应,引发中断过程。

对于8086CPU不可屏蔽中断的中断类型码固定为2。

**外中断处理过程**

**可屏蔽中断所引发的中断过程**

(1)取中断类型码n;

(2)标志寄存器入栈,IF=0,TF=0;

(3)CS、IP入栈;

(4)`(IP)=(n*4),CS=((n)*4+2)`

由此转去执行中断处理程序。

可屏蔽中断信息来自于CPU外部,中断类型码是通过数据总线送入CPU;
(对比内中断:中断类型码是在CPU内部产生的。)

将IF置o的原因:进入中断处理程序后,禁止其他的可屏蔽中断。
如果在中断处理程序中需要处理可屏蔽中断,可以用指令将IF置1。

**不可屏蔽中断的中断过程**

(1)标志寄存器入栈,IF=0,TF=0;

(2)CS、IP入栈;

(3)(IP)=(8),(CS)=(0AH)。

**8086CPU提供的设置IF的指令:**

sti,用于设置IF=1;

cli,用于设置IF=0。

## 60.PC机键盘的处理过程

键盘输入的处理过程

1.键盘输入

键盘上的每一个键相当于一个开关,键盘中有一个芯片对键盘上的每一个键的开关状态进行扫描。

**按下一个键时的操作**

开关接通,该芯片就产生一个扫描码,扫描码说明了按下的键在键盘上的位置。

扫描码被送入主板上的相关接口芯片的寄存器中,该寄存器的端口地址为60H。

**松开按下的键时的操作**

产生一个扫描码,扫描码说明了松开的键在键盘上的位置。

松开按键时产生的扫描码也被送入60H端口中。

**扫描码一长度为一个字节的编码**

按下一个键时产生的扫描码一一通码,通码的第7位为0

松开一个键时产生的扫描码 -- 断码,断码的第7位为1

例:g键的通码为22H,断码为a2H

断码的计算公式：通码+80H = 断码

2.执行9号中断

键盘的输入到达60H端口时,相关的芯片就会向CPU发出中断类型码为9的可屏蔽中断信息。
CPU检测到该中断信息后,如果IF=1,则响应中断,引发中断过程,转去执行int 9中断例程。

**输入的字符键值如何保存？**

有BIOS键盘缓冲区!

BIOS键盘缓冲区:是系统启动后,BIOS用于存放int 9中断例程所接收的键盘输

入的内存区。

BIOS键盘缓冲区:可以存储15个键盘输入,一个键盘输入用一个字单元存放,高

位字节存放扫描码,低位字节存放字符码。

3.执行int 9中断例程

**BIOS中提供的处理键盘输入的int 9中断例程的工作**

1)读出60H端口中的扫描码;

2)根据扫描码分情况对待

如果是字符键的扫描码,将该扫描码和它所对应的字符码(即ASCII码)送入内存

中的BIOS键盘缓冲区;

如果是控制键(比如Ctrl)和切换键(比如CapsLock)的扫描码,则将其转变为状态

字节(用二进制位记录控制键和切换键状态的字节)写入内存中存储状态字节的

单元,

3)对键盘系统进行相关的控制,如向相关芯片发出应答信息。

## 61.定制键盘输入处理

**CPU执行int 9中断例程，处理键盘输入**

1.DOS系统提供int 9中断例程

2.按照开发需求定制处理键盘的输入

**1.关于中断处理程序入口地址面对的问题**
要将中断向量表中的int 9中断例程的入口地址改为自编的中断处理程序的入口地址。在新中断处理程序中调用原来的int 9中断例程,还需要是原来的int 9中断例程的地址
解决方法:保存原中断例程入口地址
将原来int 9中断例程的偏移地址和段地址保存在ds:[0]和ds:[2]单元中,在需要调用原来的int 9中断例程时候,到ds:[0]、ds:[2]找到

**2.如何调用原int 9指令的中断例程**
int 9已改,但仍然需要调用原int 9指令功能
解决方法:模拟对原中断例程的调用
(1)标志寄存器入栈
(2 )IF=0, TF=0
(3)CS、IP入栈
(4) `(IP)=((ds)*16+0)`
	 `(CS)=((ds)*16+2)`

## 62.用中断响应外设

**硬件中断int 9h**

由键盘上按下或松开一个键时,如果中断是允许的,就会产生int 9h中断,并转到BIOS的键盘中断处理程序。

**BIOS中断int 16h**

BIOS中断提供基本的键盘操作,
功能号(AH)=
0OH、10H-从键盘读入字符
01H、11H-读取键盘状态
02H,12H-读取键盘标志
03H-设置重复率
04H-设置键盘点击
05H-字符及其扫描码进栈在使用功能键和变换键的程序中很重要。

**DOS中断int 21h**

DOS中断提供丰富、便捷的功能调用
功能号(AH)=
01H一从键盘输入一个字符并回显
06H-读键盘字符
07H一从键盘输入一个字符不回显
08H一从键盘输入一个字符,不回显,检测CTRL-Break
OAH-输入字符到指定地址的缓冲区
OBH-读键盘状态
OCH-清除键盘缓冲区,并调用一种键盘功能

## 63.读写硬盘

**BIOS提供的磁盘直接服务--int 13h**

| 功能号 | 功能             | 功能号 | 功能           | 功能号 | 功能               |
| ------ | ---------------- | ------ | -------------- | ------ | ------------------ |
| 00H    | 磁盘系统复位     | 0AH    | 读长扇区       | 14H    | 控制器内部诊断     |
| 01H    | 读取磁盘系统状态 | 0BH    | 写长扇区       | 15H    | 读取磁盘类型       |
| 02H    | 读扇区           | 0CH    | 查询           | 16H    | 读取磁盘变化化状态 |
| 03H    | 写扇区           | 0DH    | 硬盘系统复位   | 17H    | 设置磁盘类型       |
| 04H    | 检验扇区         | 0EH    | 读扇区缓冲区   | 18H    | 设置格式化媒体类型 |
| 05H    | 格式化磁道       | 0FH    | 写扇区缓冲区   | 19H    | 磁头保护           |
| 06H    | 格式化坏磁道     | 10H    | 读取驱动器状态 | 1AH    | 格式化ESDI驱动器   |
| 07H    | 格式化驱动器     | 11H    | 校准驱动器     |        |                    |
| 08H    | 读取驱动器参数   | 12H    | 控制器RAM诊断  |        |                    |
| 09H    | 初始化硬盘参数   | 13H    | 控制器驱动诊断 |        |                    |

**用BIOS int 13h对磁盘进行读写操作**

入口参数:
(ah)=2)(2表示读扇区)
(al)=读取的扇区数
(ch)=磁道号,(cl)=扇区号
(dh)=磁头号(对于软盘即面号,一个面用一个磁头来读写)
(dl)=驱动器号:软驱从0开始,0:软驱A,1:软驱B；
						硬盘从80h开始,80h:硬盘C,81h:硬盘D
es:bx指向接收从扇区读入数据的内存区

返回参数:
操作成功:(ah)=0,(al)=读入的扇区数
操作失败:(ah)=出错代码

**DOS中断对磁盘文件的支持--int 21H**

**目录控制功能 (Directory-Control Function)**

| 功能号 | 功能         |
| ------ | ------------ |
| 39H    | 创建目录     |
| 3AH    | 删除目录     |
| 3BH    | 设置当前目录 |
| 47H    | 读取当前目录 |

**磁盘管理功能 (Disk-Management Function)**

| 功能号   | 功能               |
| -------- | ------------------ |
| 0DH      | 磁盘复位           |
| 2EH      | 设置校验标志       |
| 0EH      | 选择磁盘           |
| 36H      | 读取驱动器分配信息 |
| 19H      | 读取当前驱动器     |
| 54H      | 读取校验标志       |
| 1BH, 1CH | 读取驱动器数据     |

**文件操作功能 (File Operation Function)**

……

**文件操作功能 (FCB) (File Operation Function)**

……

**记录操作功能 (Record Function)**

……

**记录操作功能 (FCB) (Record Function)**

……

功能39H
· 功能描述:用指定的驱动器和路径创建一个新目录
· 入口参数:
AH =39H
DS:DX=指定路径的字符串地址(以o为字符串的结束标志)
· 出口参数
CF=0 -- 创建成功,否则,AX=错误号(03H或05H),其含义见错误代码表                 
